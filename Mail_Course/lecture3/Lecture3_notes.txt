Модель OSI ...

Ethernet - мак аддресс - уникальный индентификатор ПК. MTU - макс размер пакета. MTU зависит от ОС. Если пакет слишком большой - комп отправляет серверу ICMP пакет с размером MTU компа.
don't fragment - флажок в протоколе ip, который говорит, что фрагментация завершена. Чтобы удовлетворить MTU просто уменьшают размер пакета.
traceroute - проверить маршрут до опр сайта.
wireshark - 
icmp не работает по порту, тоесть нет порта.

ipv6. 
Маска подсети - единики потом нолкики. Единички - там расположен аддресс сети, нолик - тут расположен айпи клиента. 
NAT - network address translation - есть айпишники, которые могут быть только на локкальной сети, а в интернете их не может быть (пример 127. ...., 192.168. ...). Nat транслирует такие 
аддреса в сетевые аддреса.
ipv6 не обладает NAT, так как там очень много различных комбинаций цифр может быть.

В домашней сети айпишник не нужен, так как там все по мак аддресу.
Если отправляем куда то пакет, то мак аддресс меняется каждый раз до следующего устройства. Комп -> роутер -> щиток и тд по пути.

ARP - address resolution protocol. Броудкастим сообщение всем роутерам и спрашиваем, какой роутер содержит айпи определенный. Когда узнали - добавили мак адресс роутера в ARP таблицу.

DHCP - протокол, который назначает айпи аддреса юзерам сети. DHCP Server - тот, кто раздает айпишники. Запоминает, какой был айпишник был в прошлый раз и 

UDP - порт отправителя, порт получателя, длинна датаграммы (< MTU), контрольная сумма, данные. Если датаграмма битая - она не приходит вообще. Нормальное приложение должно читать данные
по одной датаграмме. Преймущество перед tcp - он работает быстрее (нет авторизации, рукопожатий, syn, ack, балансировки отправки пакетов и тд).

Контрольная сумма - число, проверяющее целостность данных по определенному алгаритму.

DNS - преобразует символьное имя в айпишник. Домены разделены на уровни. DNS кэшируется => часть клиентов стучатся по одному айпи, часть по новому.
Записи в DNS сервере: А запись - айпишник. Syname - алиас. ...

Датаграмма (англ. datagram, дейтаграмма) — блок информации, передаваемый протоколом без предварительного установления соединения и создания виртуального канала.

TCP. Соединение определяется по айпи отправителя - айпи получателя, порты: порт источника - порт назначения.
В TCP нет понятия пакета, есть понятие соединение. Полнодплексный протокол.
Установка соединения. C посылает SYN seq=x. S отвечает syn = y ack = x + 1. C отвечает ack = y + 1.
Состояния сеанса TCP: в презентации. Состояние TIME_WAIT - ?
netstat - посмотреть все соединения текущие.
Ack - подтверждение получение сообщения.
Окно TCP - количество сегментов, которые могут быть отправленыодновременно. Связано с пропускной способностью сети.
Ситация - программист шлет по 1 байту в приложении. Заголовки 40 байт => большой оверхеад на сеть! приложение будет работать медленно.
Замедленный acknowledgement - если нам надо отправить мало данных только для подтверждения, ждем накопления буфера и посылаем сразу все.
Selective acknowledgement - допустим мы послали данные, 0-10 пакеты дошли, 10-20 не дошли, 20-30 дошли. По дефолту TCP будет слать все данные от 10 до 30, но Selective acknowledgement
позволяет отправить только 10-20 пакеты.
Алагаритм Нейгла позволяет повысить эффективность работы сетей TCP - уменьшает количество пакетов, отправляемых по сети.

HTTP
Connection: keep-alive - позволяет не закрывать connection какое то время для того, чтобы догрузить потом еще какие то расурсы с сайта (картинки, js, ...) - оптимизация.
Заголовок host - на какой сайт идем - так как может быть на одном айпи несколько сайтов.

HTTP 2.0 
-Бинарный протокол;
-Кэширование загаловков - послали набор заголовков - они закэшировались;
-Сжатие заголовокой в бинарный вид;
-Мультиплексирование.
=> в итоге HTTP 2.0 работает быстрее!!!
JRPC - замена REST API. JRPC работает с HTTP 2.0.

Факторы нагрузки (HighLoad)
-rps - request per second;
-Число одновременных соединений - соединения не должны простаивать;
-Latancy - время обслуживания одного клиента; Throughpu - число обрработанных клиентов в единицу времени.
Проблема медленных клиентов - ?

Frontend: 
-SSL терминировани. SSL - шифровка трафика, чтобы была не возможна атака по середине.
-Обработка медл клиентов
-статика
-Keep-alive 
-Кэширование.
PageCache - загрузка файлов в оперативную память. Файлы сначала загружаются в оп память - page cahce - потом уже читается. Если же мы отдаем статику, то так как файлов огр количество, 
то они все загрузятся в оп память.

РАСПЕЧАТАТЬ ЦИФРЫ ВРЕМЯ ДОСТУПА К ДАННЫМ!
Сходить по сети к локальному дата - центру быстрее, чем обратиться к жесткому диску!!!

Способы архитектуры веб - сервера:
1) 1 процесс на 1 клиента - Создаем пулл процессов и обрабатываем ими клиентов. Apache - пример.
2) Ассинхронная обработка - обработка event - driven - сложная очень.
3) Многопоточная - дешевле чем многопроцессорная, но дороже чем ассинхронная.

DNS- балансировка: Сервер разделяют на несколько серверов для уменьшеня нагрузки и днс - сервер отдает случайный айпишник из возможных каждый раз для распределения нагрузки.

Горизонтальное масштабирование - добавление новыйх серверов. Сложно программировать, так как должно быть не важно, на какой сервер приходит запрос.
Вертикальное масштабирование - поставить более мощное железо. Минус - ограничен масимально возможным железом на рынке.

Очереди
нужно для того, чтобы, если сервер перегружен, добавить в очередь письмо и доставить его в любом случае.